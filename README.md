# task4
Практическое задание #04

Анализ и обработка текстовой информа-
ции с использованием Java-средств и ре-
гулярных выражений

Требования

1) C использование методологии ООП и архитектурного шаблона проектирова-
ния MVC необходимо спроектировать и реализовать на языке программиро-
вания Java программную систему, которая анализирует и разбирает текст из
учебника по программированию, а также предоставляет дополнительные
операции согласно своему варианту задания (вариант заданий можно вы-
брать самостоятельно, но не менее двух).

2) Информация для обработки должна браться из текстового файла.

3) Разобранный текст должен быть представлен в виде соответствующих объек-
тов-сущностей. К примеру, бизнес-объект ассоциированный непосред-
ственно с текстом, содержит внутри себя, абзацы. Объекты-абзацы могут со-
держать предложения и блоки программного кода. Объект, ассоциированный
с предложением, может в свою очередь содержать слова или какие-нибудь
части предложения. Слова предложения (части предложения) могут быть да-
лее разделены, к примеру, на простые слова и знаки препинания, и т.д.

4) Классы-сущности не следует перегружать (писать лишнее) методами, выпол-
няющими функциональные действия (методами бизнес-логики и т.д.).

5) Программный код, который осуществляет анализ и разбитие текста на состав-
ные объекты-сущности, должен быть оформлен в виде специальных классов-
парсеров. Данные классы должны лимитировать создание на их базе объек-
тов.

6) Для анализа и разбора текста следует использовать регулярные выражения
(regex) и соответствующие стандартные библиотечные классы Java: String и
StringBuilder, Pattern и Matcher из пакета java.util.regex, и мн. др.


7) Не забываем, что регулярные выражения являются в коде литералами, а сле-
довательно, требуют вынесения себя в именные константы или конфигураци-
онные файлы.

8) Исходный текст необходимо разобрать на объекты-сущности таким образом,
чтобы его можно было в последующем восстановить в первоначальный вид,
т.е. оригинальный текст и текст, который получается в результате восстанов-
ления, должны полностью совпадать – это и будет показателем высокого ка-
чества разработанных классов-парсеров. (Исключение: небольшое измене-
ние могут претерпеть только пробельные символы – пробелы, знаки табуля-
ции и другие пробельные символы при разборе могут быть заменены на один
пробел.)

9) При проектировании и разработке системы необходимо полностью исполь-
зовать своё ООП-воображение, SOLID и GRASP принципы, а также возможно-
сти, которые предоставляет язык программирования Java.

10)Особенно придерживайтесь Single Responsibility Principle, SRP (принципа един-
ственной ответственности): у каждого пакета, класса или метода должна быть
только одна ответственность (цель), т.е. должна быть только одна причина из-
менить в дальнейшем соответствующий программный код.

11)При реализации задания можно (нужно) использовать шаблоны проектиро-
вания Composite и Chain of Responsibility.

12)Для реализации бизнес-логики приложения разработать соответствующие
функциональные классы, которые соответствуют решению поставленного за-
дания. Объекты данных классов и будут манипулировать бизнес-объектами
для реализации основного поведения программной системы.

13)Для реализации полновесного законченного приложения необходимо также
предусмотреть утилитные (вспомогательные) классы, которые в основном
служат для генерации входных данных и конфигурирования системы.

14)С помощью соответствующего ПО или бумажных листов обязательно приве-
сти UML-диаграмму классов спроектированной программной системы с отоб-
ражением всех типов связей (отношений) между классами и объектами спро-
ектированной программной системы.

15)При реализации компонентов приложения необходимо по максимуму пы-
таться разрабатывать универсальный, масштабируемый и легко поддержива-
емый и читаемый код.

16)Основные классы системы должны быть самодостаточными, т.е. не зависеть,
к примеру, от консоли! Любые типы отношений между классами (агрегация,
композиция, ассоциация, наследование и т.д.) должны применяться обосно-
вано и лишь тогда, когда это имеет смысл.

17)Каждый пользовательский тип должен иметь адекватное осмысленное имя и
соответствующий информативный состав (сюда могут входить соответствую-
щие конструкторы: по умолчанию, с параметрами, конструктор-копирования;
get- и set-методы для доступа к состоянию объекта; корректно переопреде-
лённые методы базового класса Object: toString(), equals(), hashCode() и др.).

18)Создаваемые типы должны быть грамотно структурированы по соответству-
ющим пакетам, которые должны иметь «адекватные» названия и начинаться
с: by.epam.javawebtraining.studentname.task04.

19)Программа должна обязательно быть снабжена комментариями-разработ-
чика, в которых необходимо указать ФИО разработчика, дату разработки и т.д.
Исходный текст классов и демонстрационной программы рекомендуется
также снабжать комментариями.

20)Язык интерфейса приложения и комментариев должен быть обязательно ан-
глийский.

21)Для проверки работоспособности логики и адекватности приложения необ-
ходимо разработать соответствующие модульные тесты с использование те-
стового unit-фреймворка Apache jUnit версии 4.0 и младше.

22)Приложение должно корректно обрабатывать любые исключительные ситу-
ации, которые могут возникнуть в процессе работы программы, а также вести

журналирование данных и других ситуаций программной системы с исполь-
зованием библиотеки логгирования Apache Log4j.

23)Не надо реализовывать никакого пользовательского меню. Использовать
консоль не рекомендуется.

24)При разработке программ придерживайтесь соглашений по написанию кода
на JAVA (Java Code-Convention).

Индивидуальные задания
1) Вывести все предложения заданного текста в порядке возрастания/убывания
их общих длин.

2) Найти наибольшее количество предложений текста, в которых есть одинако-
вые слова.

3) Вывести все предложения заданного текста в порядке возрастания/убывания
количества слов в каждом из них.

4) Найти такое слово в первом предложении, которого нет ни в одном из осталь-
ных предложений.

5) Во всех вопросительных предложениях текста найти и напечатать без повто-
рений слова заданной длины.

6) В каждом предложении текста поменять местами первое слово с последним,
не изменяя длины предложения.

7) Напечатать слова текста в алфавитном порядке по первой букве. Слова, начи-
нающиеся с новой буквы, печатать с красной строки.

8) Рассортировать слова текста по возрастанию доли гласных букв (отношение
количества гласных к общему количеству букв в слове).
9) Слова текста, начинающиеся с гласных букв, рассортировать в алфавитном
порядке по первой согласной букве слова.
10)Все слова текста рассортировать по возрастанию количества заданной буквы

в слове. Слова с одинаковым количеством расположить в алфавитном по-
рядке.

11)Существует текст и список слов. Для каждого слова из заданного списка найти,
сколько раз оно встречается в каждом предложении, и рассортировать слова
по убыванию общего количества вхождений.
12)В каждом предложении текста исключить подстроку максимальной длины,
начинающуюся и заканчивающуюся заданными символами.
13)Из текста удалить все слова заданной длины, начинающиеся на согласную
букву.

14)Отсортировать слова в тексте по убыванию/возрастанию количества вхожде-
ний заданного символа, а в случае равенства – по алфавиту.

15)В заданном тексте найти подстроку максимальной длины, являющуюся палин-
дромом, т.е. читающуюся слева направо и справа налево одинаково.

16)Преобразовать каждое слово в тексте, удалив из него все последующие вхож-
дения первой буквы этого слова.

17)Преобразовать каждое слово в тексте, удалив из него все предыдущие вхож-
дения последней буквы этого слова.

18)В некотором предложении текста слова заданной длины заменить указанной
подстрокой, длина которой может не совпадать с длиной слова.
19)Преобразовать каждое слово в тексте, удалив из него все гласные/согласные
буквы.
20)Реверсировать (переставить предложение задом наперёд) все предложения
текста.

Best of LUCK with it, and remember to HAVE FUN while you’re learning :)
Victor Ivanchenko


Пример текста для разбора
Autoboxing and Unboxing
Autoboxing is the automatic conversion that the Java compiler makes between the primitive types
and their corresponding object wrapper classes. For example, converting an int to an Integer, a
double to a Double, and so on. If the conversion goes the other way, this is called unboxing.
Here is the simplest example of autoboxing:
Character ch = 'a';
The rest of the examples in this section use generics. If you are not yet familiar with the syntax of
generics, see the Generics (Updated) lesson.
Consider the following code:
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
li.add(i);
Although you add the int values as primitive types, rather than Integer objects, to li, the code
compiles. Because li is a list of Integer objects, not a list of int values, you may wonder why
the Java compiler does not issue a compile-time error. The compiler does not generate an error
because it creates an Integer object from i and adds the object to li. Thus, the compiler converts
the previous code to the following at runtime:
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
li.add(Integer.valueOf(i));
Converting a primitive value (an int, for example) into an object of the corresponding wrapper
class (Integer) is called autoboxing. The Java compiler applies autoboxing when a primitive
value is:
 passed as a parameter to a method that expects an object of the corresponding wrapper class;
 assigned to a variable of the corresponding wrapper class.
Consider the following method:
public static int sumEven(List<Integer> li) {
int sum = 0;
for (Integer i: li)
if (i % 2 == 0)
sum += i;
return sum;
}
Because the remainder (%) and unary plus (+=) operators do not apply to Integer objects, you may
wonder why the Java compiler compiles the method without issuing any errors. The compiler does

Java Information Handling & Regular Expressions

7 | We hope you enjoy working with Java!
not generate an error because it invokes the intValue method to convert an Integer to an int at
runtime:
public static int sumEven(List<Integer> li) {
int sum = 0;
for (Integer i : li)
if (i.intValue() % 2 == 0)
sum += i.intValue();
return sum;
}
Converting an object of a wrapper type (Integer) to its corresponding primitive (int) value is
called unboxing. The Java compiler applies unboxing when an object of a wrapper class is:
 passed as a parameter to a method that expects a value of the corresponding primitive type;
 assigned to a variable of the corresponding primitive type.
The Unboxing example shows how this works:
import java.util.ArrayList;
import java.util.List;
public class Unboxing {
public static void main(String[] args) {
Integer i = new Integer(-8);
// 1. Unboxing through method invocation
int absVal = absoluteValue(i);
System.out.println("absolute value of " + i + " = " + absVal);
List<Double> ld = new ArrayList<>();
ld.add(3.1416); // Π is autoboxed through method invocation.
// 2. Unboxing through assignment
double pi = ld.get(0);
System.out.println("pi = " + pi);
}
public static int absoluteValue(int i) {
return (i < 0) ? -i : i;
}
}
The program prints the following:
absolute value of -8 = 8
pi = 3.1416
Autoboxing and unboxing lets developers write cleaner code, making it easier to read.
